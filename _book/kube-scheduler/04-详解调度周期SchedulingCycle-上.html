
<!DOCTYPE HTML>
<html lang="zh-hans" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>详解调度周期SchedulingCycle(上) · Kubernetes Learning</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        <meta name="author" content="lts0609">
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-pageview-count/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-page-toc-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-page-treeview/style.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-splitter/splitter.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search-pro/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-auto-scroll-table/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-anchors/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-prism/prism-tomorrow.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-tbfed-pagefooter/footer.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="05-详解调度周期SchedulingCycle-下.html" />
    
    
    <link rel="prev" href="03-Framework框架和调度流程.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="输入并搜索" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Kubernetes源码学习
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="./">
            
                <a href="./">
            
                    
                    Scheduler
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="01-Scheduler创建流程与调度队列.html">
            
                <a href="01-Scheduler创建流程与调度队列.html">
            
                    
                    Scheduler创建流程与调度队列
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="02-调度器缓存Cache的实现.html">
            
                <a href="02-调度器缓存Cache的实现.html">
            
                    
                    调度器缓存Cache的实现
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="03-Framework框架和调度流程.html">
            
                <a href="03-Framework框架和调度流程.html">
            
                    
                    Framework框架和调度流程
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.2.4" data-path="04-详解调度周期SchedulingCycle-上.html">
            
                <a href="04-详解调度周期SchedulingCycle-上.html">
            
                    
                    详解调度周期SchedulingCycle(上)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="05-详解调度周期SchedulingCycle-下.html">
            
                <a href="05-详解调度周期SchedulingCycle-下.html">
            
                    
                    详解调度周期SchedulingCycle(下)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="06-详解绑定周期BindingCycle.html">
            
                <a href="06-详解绑定周期BindingCycle.html">
            
                    
                    详解绑定周期BindingCycle
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="07-失败处理与抢占调度Preemption.html">
            
                <a href="07-失败处理与抢占调度Preemption.html">
            
                    
                    失败处理与抢占调度Preemption
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="08-调度器扩展与实践.html">
            
                <a href="08-调度器扩展与实践.html">
            
                    
                    调度器扩展与实践
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../kube-controller-manager/">
            
                <a href="../kube-controller-manager/">
            
                    
                    Controller Manager
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../kube-controller-manager/01-ControllerManager创建流程.html">
            
                <a href="../kube-controller-manager/01-ControllerManager创建流程.html">
            
                    
                    ControllerManager创建流程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../kube-controller-manager/02-DeploymentController原理详解.html">
            
                <a href="../kube-controller-manager/02-DeploymentController原理详解.html">
            
                    
                    DeploymentController原理详解
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            本书使用 GitBook 发布
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >详解调度周期SchedulingCycle(上)</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <div class="treeview__container"><ul>
<li><div><a href="#schedulepod&#x9636;&#x6BB5;">SchedulePod&#x9636;&#x6BB5;</a><i class="level__parent level__item level__parent--opened" state="opened" onclick="var curState = this.getAttribute(&apos;state&apos;);var nextState = curState === &apos;opened&apos; ? &apos;hidden&apos; : &apos;opened&apos;;this.setAttribute(&apos;state&apos;, nextState);this.className = this.className.split(curState).join(nextState);var list = this.parentNode.nextElementSibling;if (nextState === &apos;hidden&apos;) {    list.style.display = &apos;none&apos;;} else {    list.style.display = &apos;block&apos;;}"></i></div>
<ul>
<li><div><a href="#predicates&#x9636;&#x6BB5;">Predicates&#x9636;&#x6BB5;</a><i class="level__parent level__item level__parent--opened" state="opened" onclick="var curState = this.getAttribute(&apos;state&apos;);var nextState = curState === &apos;opened&apos; ? &apos;hidden&apos; : &apos;opened&apos;;this.setAttribute(&apos;state&apos;, nextState);this.className = this.className.split(curState).join(nextState);var list = this.parentNode.nextElementSibling;if (nextState === &apos;hidden&apos;) {    list.style.display = &apos;none&apos;;} else {    list.style.display = &apos;block&apos;;}"></i></div>
<ul>
<li><div><a href="#&#x6838;&#x5FC3;&#x51FD;&#x6570;findnodesthatfitpod">&#x6838;&#x5FC3;&#x51FD;&#x6570;findNodesThatFitPod</a><i></i></div></li>
<li><div><a href="#prefilter&#x6269;&#x5C55;&#x70B9;">PreFilter&#x6269;&#x5C55;&#x70B9;</a><i></i></div></li>
<li><div><a href="#filter&#x6269;&#x5C55;&#x70B9;">Filter&#x6269;&#x5C55;&#x70B9;</a><i class="level__parent level__item level__parent--opened" state="opened" onclick="var curState = this.getAttribute(&apos;state&apos;);var nextState = curState === &apos;opened&apos; ? &apos;hidden&apos; : &apos;opened&apos;;this.setAttribute(&apos;state&apos;, nextState);this.className = this.className.split(curState).join(nextState);var list = this.parentNode.nextElementSibling;if (nextState === &apos;hidden&apos;) {    list.style.display = &apos;none&apos;;} else {    list.style.display = &apos;block&apos;;}"></i></div>
<ul>
<li><div><a href="#&#x8282;&#x70B9;&#x5217;&#x8868;&#x957F;&#x5EA6;&#x786E;&#x5B9A;&#x89C4;&#x5219;">&#x8282;&#x70B9;&#x5217;&#x8868;&#x957F;&#x5EA6;&#x786E;&#x5B9A;&#x89C4;&#x5219;</a><i></i></div></li>
<li><div><a href="#&#x8FD0;&#x884C;filter&#x63D2;&#x4EF6;">&#x8FD0;&#x884C;Filter&#x63D2;&#x4EF6;</a><i></i></div></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>

<h1 id="&#x8BE6;&#x89E3;&#x8C03;&#x5EA6;&#x5468;&#x671F;schedulingcycle&#x4E0A;"><a name="&#x8BE6;&#x89E3;&#x8C03;&#x5EA6;&#x5468;&#x671F;schedulingcycle&#x4E0A;" class="plugin-anchor" href="#&#x8BE6;&#x89E3;&#x8C03;&#x5EA6;&#x5468;&#x671F;schedulingcycle&#x4E0A;"><i class="fa fa-link" aria-hidden="true"></i></a>&#x8BE6;&#x89E3;&#x8C03;&#x5EA6;&#x5468;&#x671F;SchedulingCycle(&#x4E0A;)</h1>
<p>&#x8C03;&#x5EA6;&#x5468;&#x671F;&#x7684;&#x5B9E;&#x73B0;&#x53EF;&#x4EE5;&#x8BF4;&#x662F;&#x6574;&#x4E2A;&#x8C03;&#x5EA6;&#x5668;&#x7684;&#x6838;&#x5FC3;&#x5185;&#x5BB9;&#xFF0C;&#x6240;&#x4EE5;&#x5C55;&#x5F00;&#x8BF4;&#x660E;&#x3002;&#x5728;<code>ScheduleOne()</code>&#x4E2D;&#x8C03;&#x5EA6;&#x5468;&#x671F;&#x7684;&#x5165;&#x53E3;&#x65B9;&#x6CD5;&#x662F;<code>schedulingCycl()</code>&#x3002;</p>
<pre class="language-"><code class="lang-Go">scheduleResult, assumedPodInfo, status := sched.schedulingCycle(schedulingCycleCtx, state, fwk, podInfo, start, podsToActivate)
</code></pre>
<p>&#x6839;&#x636E;&#x51FD;&#x6570;&#x7B7E;&#x540D;&#x90E8;&#x5206;&#xFF0C;&#x5B83;&#x63A5;&#x6536;&#x516D;&#x4E2A;&#x53C2;&#x6570;&#xFF0C;&#x5305;&#x62EC;&#x8C03;&#x5EA6;&#x5468;&#x671F;&#x7684;&#x4E0A;&#x4E0B;&#x6587;<code>ctx</code>&#xFF0C;&#x7528;&#x4E8E;&#x534F;&#x7A0B;&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;&#x7BA1;&#x7406;;&#x8C03;&#x5EA6;&#x5468;&#x671F;&#x72B6;&#x6001;<code>state</code>&#xFF0C;&#x8C03;&#x5EA6;&#x63D2;&#x4EF6;&#x901A;&#x8FC7;&#x8BE5;&#x5BF9;&#x8C61;&#x8BFB;&#x53D6;&#x6216;&#x5199;&#x5165;&#x6570;&#x636E;&#x4EE5;&#x4FBF;&#x534F;&#x540C;&#x5DE5;&#x4F5C;;&#x8C03;&#x5EA6;&#x6846;&#x67B6;&#x63A5;&#x53E3;&#x5BF9;&#x8C61;<code>fwk</code>&#xFF0C;&#x8C03;&#x5EA6;&#x8FC7;&#x7A0B;&#x4E2D;&#x6839;&#x636E;<code>Pod.Status.SchedulerName</code>&#x5B57;&#x6BB5;&#x8C03;&#x5EA6;&#x6846;&#x67B6;&#x83B7;&#x53D6;&#x5BF9;&#x5E94;<code>Framework</code>&#x5B9E;&#x4F8B;&#xFF0C;&#x5BF9;&#x5E94;&#x8C03;&#x5EA6;&#x6D41;&#x7A0B;&#x4E2D;&#x7684;&#x914D;&#x7F6E;&#x4EE5;&#x53CA;&#x6269;&#x5C55;&#x70B9;&#x63D2;&#x4EF6;&#x5217;&#x8868;;Pod&#x7684;&#x4FE1;&#x606F;<code>podInfo</code>&#xFF0C;&#x6839;&#x636E;&#x5176;&#x4E2D;&#x7684;&#x4FE1;&#x606F;&#x9009;&#x62E9;&#x8282;&#x70B9;;&#x5F00;&#x59CB;&#x8C03;&#x5EA6;&#x7684;&#x65F6;&#x95F4;&#x6233;<code>start</code>;&#x5F85;&#x6FC0;&#x6D3B;Pod&#x96C6;&#x5408;<code>podsToActivate</code>&#x3002;</p>
<pre class="language-"><code class="lang-Go">func (sched *Scheduler) schedulingCycle(
    ctx context.Context,
    state *framework.CycleState,
    fwk framework.Framework,
    podInfo *framework.QueuedPodInfo,
    start time.Time,
    podsToActivate *framework.PodsToActivate,
) (ScheduleResult, *framework.QueuedPodInfo, *framework.Status)
</code></pre>
<p>&#x7136;&#x540E;&#x6765;&#x5206;&#x6790;<code>schedulingCycle()</code>&#x65B9;&#x6CD5;&#x7684;&#x5B9E;&#x73B0;&#x903B;&#x8F91;&#xFF0C;&#x5B8C;&#x6574;&#x4EE3;&#x7801;&#x5982;&#x4E0B;&#x3002;</p>
<pre class="language-"><code class="lang-Go">// schedulingCycle tries to schedule a single Pod.
func (sched *Scheduler) schedulingCycle(
    ctx context.Context,
    state *framework.CycleState,
    fwk framework.Framework,
    podInfo *framework.QueuedPodInfo,
    start time.Time,
    podsToActivate *framework.PodsToActivate,
) (ScheduleResult, *framework.QueuedPodInfo, *framework.Status) {
    logger := klog.FromContext(ctx)
    pod := podInfo.Pod
    scheduleResult, err := sched.SchedulePod(ctx, fwk, state, pod)
    if err != nil {
        defer func() {
            metrics.SchedulingAlgorithmLatency.Observe(metrics.SinceInSeconds(start))
        }()
        if err == ErrNoNodesAvailable {
            status := framework.NewStatus(framework.UnschedulableAndUnresolvable).WithError(err)
            return ScheduleResult{nominatingInfo: clearNominatedNode}, podInfo, status
        }

        fitError, ok := err.(*framework.FitError)
        if !ok {
            logger.Error(err, &quot;Error selecting node for pod&quot;, &quot;pod&quot;, klog.KObj(pod))
            return ScheduleResult{nominatingInfo: clearNominatedNode}, podInfo, framework.AsStatus(err)
        }

        if !fwk.HasPostFilterPlugins() {
            logger.V(3).Info(&quot;No PostFilter plugins are registered, so no preemption will be performed&quot;)
            return ScheduleResult{}, podInfo, framework.NewStatus(framework.Unschedulable).WithError(err)
        }

        // Run PostFilter plugins to attempt to make the pod schedulable in a future scheduling cycle.
        result, status := fwk.RunPostFilterPlugins(ctx, state, pod, fitError.Diagnosis.NodeToStatus)
        msg := status.Message()
        fitError.Diagnosis.PostFilterMsg = msg
        if status.Code() == framework.Error {
            logger.Error(nil, &quot;Status after running PostFilter plugins for pod&quot;, &quot;pod&quot;, klog.KObj(pod), &quot;status&quot;, msg)
        } else {
            logger.V(5).Info(&quot;Status after running PostFilter plugins for pod&quot;, &quot;pod&quot;, klog.KObj(pod), &quot;status&quot;, msg)
        }

        var nominatingInfo *framework.NominatingInfo
        if result != nil {
            nominatingInfo = result.NominatingInfo
        }
        return ScheduleResult{nominatingInfo: nominatingInfo}, podInfo, framework.NewStatus(framework.Unschedulable).WithError(err)
    }

    metrics.SchedulingAlgorithmLatency.Observe(metrics.SinceInSeconds(start))

    assumedPodInfo := podInfo.DeepCopy()
    assumedPod := assumedPodInfo.Pod
    // assume modifies `assumedPod` by setting NodeName=scheduleResult.SuggestedHost
    err = sched.assume(logger, assumedPod, scheduleResult.SuggestedHost)
    if err != nil {
        return ScheduleResult{nominatingInfo: clearNominatedNode}, assumedPodInfo, framework.AsStatus(err)
    }

    // Run the Reserve method of reserve plugins.
    if sts := fwk.RunReservePluginsReserve(ctx, state, assumedPod, scheduleResult.SuggestedHost); !sts.IsSuccess() {
        // trigger un-reserve to clean up state associated with the reserved Pod
        fwk.RunReservePluginsUnreserve(ctx, state, assumedPod, scheduleResult.SuggestedHost)
        if forgetErr := sched.Cache.ForgetPod(logger, assumedPod); forgetErr != nil {
            logger.Error(forgetErr, &quot;Scheduler cache ForgetPod failed&quot;)
        }

        if sts.IsRejected() {
            fitErr := &amp;framework.FitError{
                NumAllNodes: 1,
                Pod:         pod,
                Diagnosis: framework.Diagnosis{
                    NodeToStatus: framework.NewDefaultNodeToStatus(),
                },
            }
            fitErr.Diagnosis.NodeToStatus.Set(scheduleResult.SuggestedHost, sts)
            fitErr.Diagnosis.AddPluginStatus(sts)
            return ScheduleResult{nominatingInfo: clearNominatedNode}, assumedPodInfo, framework.NewStatus(sts.Code()).WithError(fitErr)
        }
        return ScheduleResult{nominatingInfo: clearNominatedNode}, assumedPodInfo, sts
    }

    // Run &quot;permit&quot; plugins.
    runPermitStatus := fwk.RunPermitPlugins(ctx, state, assumedPod, scheduleResult.SuggestedHost)
    if !runPermitStatus.IsWait() &amp;&amp; !runPermitStatus.IsSuccess() {
        // trigger un-reserve to clean up state associated with the reserved Pod
        fwk.RunReservePluginsUnreserve(ctx, state, assumedPod, scheduleResult.SuggestedHost)
        if forgetErr := sched.Cache.ForgetPod(logger, assumedPod); forgetErr != nil {
            logger.Error(forgetErr, &quot;Scheduler cache ForgetPod failed&quot;)
        }

        if runPermitStatus.IsRejected() {
            fitErr := &amp;framework.FitError{
                NumAllNodes: 1,
                Pod:         pod,
                Diagnosis: framework.Diagnosis{
                    NodeToStatus: framework.NewDefaultNodeToStatus(),
                },
            }
            fitErr.Diagnosis.NodeToStatus.Set(scheduleResult.SuggestedHost, runPermitStatus)
            fitErr.Diagnosis.AddPluginStatus(runPermitStatus)
            return ScheduleResult{nominatingInfo: clearNominatedNode}, assumedPodInfo, framework.NewStatus(runPermitStatus.Code()).WithError(fitErr)
        }

        return ScheduleResult{nominatingInfo: clearNominatedNode}, assumedPodInfo, runPermitStatus
    }

    // At the end of a successful scheduling cycle, pop and move up Pods if needed.
    if len(podsToActivate.Map) != 0 {
        sched.SchedulingQueue.Activate(logger, podsToActivate.Map)
        // Clear the entries after activation.
        podsToActivate.Map = make(map[string]*v1.Pod)
    }

    return scheduleResult, assumedPodInfo, nil
}
</code></pre>
<h2 id="schedulepod&#x9636;&#x6BB5;"><a name="schedulepod&#x9636;&#x6BB5;" class="plugin-anchor" href="#schedulepod&#x9636;&#x6BB5;"><i class="fa fa-link" aria-hidden="true"></i></a>SchedulePod&#x9636;&#x6BB5;</h2>
<p>&#x56E0;&#x4E3A;&#x9009;&#x8282;&#x70B9;&#x5931;&#x8D25;&#x4F1A;&#x89E6;&#x53D1;&#x62A2;&#x5360;&#x6D41;&#x7A0B;&#xFF0C;&#x5148;&#x5BF9;&#x53EF;&#x4EE5;&#x6210;&#x529F;&#x9009;&#x5230;&#x8282;&#x70B9;&#x7684;&#x6807;&#x51C6;&#x60C5;&#x51B5;&#x8FDB;&#x884C;&#x4E86;&#x89E3;&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x4E0B;&#x9762;&#x7B80;&#x5316;&#x540E;&#x7684;&#x4EE3;&#x7801;&#x7247;&#x6BB5;&#xFF0C;&#x505A;&#x6982;&#x8FF0;&#x8BF4;&#x660E;&#x3002;&#x9996;&#x5148;&#x8C03;&#x7528;<code>sched.SchedulePod()</code>&#x65B9;&#x6CD5;&#xFF0C;&#x8FD9;&#x4E2A;&#x6B65;&#x9AA4;&#x53EF;&#x4EE5;&#x8BF4;&#x662F;&#x6574;&#x4E2A;&#x8C03;&#x5EA6;&#x5468;&#x671F;&#x7684;&#x6838;&#x5FC3;&#xFF0C;&#x5176;&#x4E2D;&#x5305;&#x62EC;&#x4E86;&#x6211;&#x4EEC;&#x5E38;&#x8BF4;&#x7684;&#x9884;&#x9009;<code>Predicates</code>&#x548C;&#x4F18;&#x9009;<code>Priorities</code>&#x6D41;&#x7A0B;&#x3002;&#x56DE;&#x987E;&#x4E00;&#x4E0B;&#x8C03;&#x5EA6;&#x5668;&#x5B9E;&#x4F8B;&#x7684;&#x521B;&#x5EFA;<code>sched.applyDefaultHandlers()</code>&#x6B65;&#x9AA4;&#x4E2D;&#x8BBE;&#x7F6E;&#x4E86;<code>&#x8C03;&#x5EA6;&#x51FD;&#x6570;</code>&#x548C;<code>&#x8C03;&#x5EA6;&#x5931;&#x8D25;handler</code>&#xFF0C;&#x6CA1;&#x6709;&#x91C7;&#x7528;&#x786C;&#x7F16;&#x7801;&#x7684;&#x65B9;&#x5F0F;&#x8BBE;&#x7F6E;&#x903B;&#x8F91;&#xFF0C;&#x63D0;&#x9AD8;&#x4E86;&#x4EE3;&#x7801;&#x7684;&#x7075;&#x6D3B;&#x6027;&#x3002;</p>
<pre class="language-"><code class="lang-Go">func (sched *Scheduler) schedulingCycle(
    ctx context.Context,
    state *framework.CycleState,
    fwk framework.Framework,
    podInfo *framework.QueuedPodInfo,
    start time.Time,
    podsToActivate *framework.PodsToActivate,
) (ScheduleResult, *framework.QueuedPodInfo, *framework.Status) {
    logger := klog.FromContext(ctx)
    pod := podInfo.Pod
    // &#x6838;&#x5FC3;&#x903B;&#x8F91; &#x8C03;&#x5EA6;Pod &#x5305;&#x542B;Predicates&#x548C;Priorities&#x5168;&#x6D41;&#x7A0B;
    scheduleResult, err := sched.SchedulePod(ctx, fwk, state, pod)
    // &#x8C03;&#x5EA6;&#x5931;&#x8D25;&#x5904;&#x7406; &#x6682;&#x4E14;&#x5FFD;&#x7565;
    ......

    metrics.SchedulingAlgorithmLatency.Observe(metrics.SinceInSeconds(start))
    // &#x907F;&#x514D;&#x5F71;&#x54CD;&#x5230;&#x539F;&#x59CB;&#x6570;&#x636E; &#x6DF1;&#x62F7;&#x8D1D;&#x4E00;&#x4E2A;&#x65B0;&#x5BF9;&#x8C61; SchedulePod&#x5B8C;&#x6210;&#x540E;Pod&#x5904;&#x4E8E;Assumed&#x9636;&#x6BB5;
    assumedPodInfo := podInfo.DeepCopy()
    assumedPod := assumedPodInfo.Pod
    // &#x4FEE;&#x6539;NodeName&#x5B57;&#x6BB5;
    err = sched.assume(logger, assumedPod, scheduleResult.SuggestedHost)
    // &#x5931;&#x8D25;&#x5904;&#x7406; &#x6682;&#x4E14;&#x5FFD;&#x7565;
    ......

    // &#x8FD0;&#x884C;&#x8D44;&#x6E90;&#x9884;&#x7559;&#x63D2;&#x4EF6; &#x6807;&#x51C6;&#x6269;&#x5C55;&#x70B9;&#x4E4B;&#x4E00;
    if sts := fwk.RunReservePluginsReserve(ctx, state, assumedPod, scheduleResult.SuggestedHost); !sts.IsSuccess() {
    // &#x8D44;&#x6E90;&#x9884;&#x7559;&#x63D2;&#x4EF6;&#x5931;&#x8D25;&#x5904;&#x7406;(&#x8FD0;&#x884C;Unreserve) &#x6682;&#x4E14;&#x5FFD;&#x7565;
        ......
    }

    // &#x8FD0;&#x884C;&#x51C6;&#x5165;&#x63D2;&#x4EF6;
    runPermitStatus := fwk.RunPermitPlugins(ctx, state, assumedPod, scheduleResult.SuggestedHost)
    if !runPermitStatus.IsWait() &amp;&amp; !runPermitStatus.IsSuccess() {
        // &#x51C6;&#x5165;&#x63D2;&#x4EF6;&#x8FD4;&#x56DE;&#x5931;&#x8D25;&#x5904;&#x7406; &#x5B8C;&#x5168;&#x540C;&#x4E0A;
        ......
    }

    // &#x8C03;&#x5EA6;&#x5468;&#x671F;&#x7ED3;&#x675F;&#x524D; &#x6FC0;&#x6D3B;&#x5F85;&#x6FC0;&#x6D3B;Pod 
    if len(podsToActivate.Map) != 0 {
        sched.SchedulingQueue.Activate(logger, podsToActivate.Map)
        // &#x6E05;&#x7406;&#x96C6;&#x5408;
        podsToActivate.Map = make(map[string]*v1.Pod)
    }
    // &#x8FD4;&#x56DE;&#x7ED3;&#x679C;
    return scheduleResult, assumedPodInfo, nil
}
</code></pre>
<p>&#x5206;&#x6790;&#x4E00;&#x4E0B;<code>schedulePod()</code>&#x65B9;&#x6CD5;&#x7684;&#x903B;&#x8F91;&#xFF0C;</p>
<pre class="language-"><code class="lang-Go">func (sched *Scheduler) schedulePod(ctx context.Context, fwk framework.Framework, state *framework.CycleState, pod *v1.Pod) (result ScheduleResult, err error) {
    // &#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x8C03;&#x5EA6;&#x8FC7;&#x7A0B;&#x4E2D;&#x7684;&#x8DDF;&#x8E2A;&#x5668;
    trace := utiltrace.New(&quot;Scheduling&quot;, utiltrace.Field{Key: &quot;namespace&quot;, Value: pod.Namespace}, utiltrace.Field{Key: &quot;name&quot;, Value: pod.Name})
    // &#x8D85;&#x8FC7;100ms&#x6253;&#x5370;&#x65E5;&#x5FD7;
    defer trace.LogIfLong(100 * time.Millisecond)
    // &#x6BCF;&#x6B21;&#x6267;&#x884C;&#x8C03;&#x5EA6;&#x7684;&#x5F00;&#x59CB;&#x4F1A;&#x66F4;&#x65B0;&#x8C03;&#x5EA6;&#x7F13;&#x5B58;
    // &#x5BF9;&#x8C61;&#x7684;&#x66F4;&#x65B0;&#x4F9D;&#x636E;&#x662F;Generation &#x7F13;&#x5B58;&#x4E2D;&#x8282;&#x70B9;&#x662F;&#x53CC;&#x5411;&#x94FE;&#x8868; &#x5F53;&#x904D;&#x5386;&#x5230;&#x8282;&#x70B9;Generation&#x5C0F;&#x4E8E;&#x5F53;&#x524D;&#x5FEB;&#x7167;Generation&#x65F6;&#x9000;&#x51FA;&#x80FD;&#x591F;&#x63D0;&#x9AD8;&#x6548;&#x7387;
    if err := sched.Cache.UpdateSnapshot(klog.FromContext(ctx), sched.nodeInfoSnapshot); err != nil {
        return result, err
    }
    trace.Step(&quot;Snapshotting scheduler cache and node infos done&quot;)
    // &#x5FEB;&#x7167;&#x4E2D;&#x6CA1;&#x6709;&#x8282;&#x70B9;&#x65F6;&#x8FD4;&#x56DE;&#x9519;&#x8BEF;
    if sched.nodeInfoSnapshot.NumNodes() == 0 {
        return result, ErrNoNodesAvailable
    }
    // &#x6838;&#x5FC3;&#x51FD;&#x6570; Predicates&#x6D41;&#x7A0B;
    feasibleNodes, diagnosis, err := sched.findNodesThatFitPod(ctx, fwk, state, pod)
    if err != nil {
        return result, err
    }
    trace.Step(&quot;Computing predicates done&quot;)
    // &#x6CA1;&#x627E;&#x5230;&#x53EF;&#x7528;&#x8282;&#x70B9;&#x8FD4;&#x56DE;&#x9519;&#x8BEF;
    if len(feasibleNodes) == 0 {
        return result, &amp;framework.FitError{
            Pod:         pod,
            NumAllNodes: sched.nodeInfoSnapshot.NumNodes(),
            Diagnosis:   diagnosis,
        }
    }

    // &#x627E;&#x5230;&#x7684;&#x53EF;&#x7528;&#x8282;&#x70B9;&#x53EA;&#x6709;&#x4E00;&#x4E2A;&#x76F4;&#x63A5;&#x9009;&#x7528; &#x4E0D;&#x9700;&#x8981;&#x540E;&#x7EED;Priorities&#x6D41;&#x7A0B;
    if len(feasibleNodes) == 1 {
        return ScheduleResult{
            SuggestedHost:  feasibleNodes[0].Node().Name,
            EvaluatedNodes: 1 + diagnosis.NodeToStatus.Len(),
            FeasibleNodes:  1,
        }, nil
    }

    // &#x6838;&#x5FC3;&#x51FD;&#x6570; Priorities&#x6D41;&#x7A0B;
    priorityList, err := prioritizeNodes(ctx, sched.Extenders, fwk, state, pod, feasibleNodes)
    if err != nil {
        return result, err
    }
    // &#x8282;&#x70B9;&#x6253;&#x5206;&#x540E;&#x7684;&#x6700;&#x7EC8;&#x9009;&#x62E9;
    host, _, err := selectHost(priorityList, numberOfHighestScoredNodesToReport)
    trace.Step(&quot;Prioritizing done&quot;)
    // &#x8FD4;&#x56DE;&#x8282;&#x70B9;&#x9009;&#x62E9;&#x7ED3;&#x679C;
    return ScheduleResult{
        SuggestedHost:  host,
        EvaluatedNodes: len(feasibleNodes) + diagnosis.NodeToStatus.Len(),
        FeasibleNodes:  len(feasibleNodes),
    }, err
}
</code></pre>
<h3 id="predicates&#x9636;&#x6BB5;"><a name="predicates&#x9636;&#x6BB5;" class="plugin-anchor" href="#predicates&#x9636;&#x6BB5;"><i class="fa fa-link" aria-hidden="true"></i></a>Predicates&#x9636;&#x6BB5;</h3>
<p>&#x5728;<code>schedulePod()</code>&#x65B9;&#x6CD5;&#x4E2D;&#xFF0C;<code>Predicates</code>&#x9636;&#x6BB5;&#x7684;&#x5165;&#x53E3;&#x4EE3;&#x7801;&#x5982;&#x4E0B;&#xFF0C;&#x5176;&#x4E2D;&#x8FD4;&#x56DE;&#x7ED3;&#x679C;&#x4E3A;<code>PodInfo</code>&#x7C7B;&#x578B;&#x7684;&#x5217;&#x8868;<code>feasibleNodes</code>&#x548C;&#x8282;&#x70B9;&#x4E0D;&#x7B26;&#x5408;&#x6761;&#x4EF6;&#x7684;&#x539F;&#x56E0;<code>diagnosis</code>&#x3002;</p>
<pre class="language-"><code class="lang-Go">feasibleNodes, diagnosis, err := sched.findNodesThatFitPod(ctx, fwk, state, pod)
</code></pre>
<p>&#x5176;&#x4E2D;<code>Diagnosis</code>&#x7C7B;&#x578B;&#x7EC4;&#x6210;&#x5982;&#x4E0B;&#xFF0C;&#x8BB0;&#x5F55;&#x5168;&#x5C40;&#x7684;<code>Predicates</code>&#x8282;&#x70B9;&#x8BCA;&#x65AD;&#x4FE1;&#x606F;&#x3002;</p>
<pre class="language-"><code class="lang-Go">type Diagnosis struct {
    // PreFilter/Filter&#x9636;&#x6BB5;&#x4E0D;&#x53EF;&#x7528;&#x8282;&#x70B9;&#x7684;&#x4FE1;&#x606F;&#x96C6;&#x5408;
    NodeToStatus *NodeToStatus
    // &#x4F7F;&#x5176;&#x8FD4;&#x56DE;UnschedulablePlugins&#x6216;UnschedulableAndUnresolvable&#x72B6;&#x6001;&#x7684;&#x63D2;&#x4EF6;&#x96C6;&#x5408;&#x4FE1;&#x606F;
    UnschedulablePlugins sets.Set[string]
    // &#x4F7F;&#x5176;&#x8FD4;&#x56DE;Pending&#x72B6;&#x6001;&#x7684;&#x63D2;&#x4EF6;&#x96C6;&#x5408;&#x4FE1;&#x606F;
    PendingPlugins sets.Set[string]
    // PreFilter&#x63D2;&#x4EF6;&#x8FD4;&#x56DE;&#x6D88;&#x606F;
    PreFilterMsg string
    // PostFilter&#x63D2;&#x4EF6;&#x8FD4;&#x56DE;&#x6D88;&#x606F;
    PostFilterMsg string
}

type NodeToStatus struct {
    nodeToStatus map[string]*Status 
    // &#x63D2;&#x4EF6;&#x8FD4;&#x56DE;&#x5931;&#x8D25;&#x540E;&#x6807;&#x8BB0;&#x8282;&#x70B9;&#x72B6;&#x6001;&#x4E3A;Unschedulable/UnschedulableAndUnresolvable
    // &#x4E0E;&#x540E;&#x7EED;&#x62A2;&#x5360;&#x903B;&#x8F91;&#x6709;&#x5173; &#x62A2;&#x5360;&#x4E0D;&#x4F1A;&#x53BB;&#x5C1D;&#x8BD5;UnschedulableAndUnresolvable&#x7684;&#x8282;&#x70B9;
    absentNodesStatus *Status
}

type Status struct {
    code    Code
    reasons []string
    err     error
    plugin string
}
</code></pre>
<p>&#x8865;&#x5145;&#x8BF4;&#x660E;&#x4E00;&#x4E0B;&#x63D2;&#x4EF6;&#x8FD4;&#x56DE;&#x7684;&#x5185;&#x90E8;&#x72B6;&#x6001;&#xFF0C;&#x4E3A;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#xFF1A;</p>
<p><code>Success</code>&#xFF1A;&#x63D2;&#x4EF6;&#x6267;&#x884C;&#x6210;&#x529F;;</p>
<p><code>Error</code>&#xFF1A;&#x5185;&#x90E8;&#x9519;&#x8BEF;&#xFF0C;&#x7ACB;&#x5373;&#x5165;&#x961F;&#x91CD;&#x8BD5;;</p>
<p><code>Unschedulable</code>&#xFF1A;&#x8868;&#x793A;&#x4E34;&#x65F6;&#x7684;&#x4E0D;&#x53EF;&#x8C03;&#x5EA6;&#xFF0C;&#x662F;&#x52A8;&#x6001;(&#x8D44;&#x6E90;)&#x7684;&#x6761;&#x4EF6;&#x4E0D;&#x6EE1;&#x8DB3;&#xFF0C;&#x6BD4;&#x5982;&#x8282;&#x70B9;CPU&#x8D44;&#x6E90;&#x4E0D;&#x8DB3;&#xFF0C;&#x8FD9;&#x79CD;&#x5931;&#x8D25;&#x540E;Pod&#x4F1A;&#x91CD;&#x65B0;&#x5165;&#x961F;&#x7B49;&#x5F85;&#x8C03;&#x5EA6;&#xFF0C;&#x6709;&#x9000;&#x907F;&#x65F6;&#x95F4;;</p>
<p><code>UnschedulableAndUnresolvable</code>&#x662F;&#x9759;&#x6001;(&#x914D;&#x7F6E;)&#x6761;&#x4EF6;&#x4E0D;&#x6EE1;&#x8DB3;&#xFF0C;&#x5982;&#x8981;&#x6C42;&#x8282;&#x70B9;&#x4E0A;&#x5B58;&#x5728;&#x67D0;&#x4E2A;&#x6807;&#x7B7E;&#x4F46;&#x5B9E;&#x9645;&#x4E0D;&#x5B58;&#x5728;&#xFF0C;&#x8C03;&#x5EA6;&#x5668;&#x4E0D;&#x4F1A;&#x91CD;&#x8BD5;&#xFF0C;&#x5BF9;&#x5E94;&#x4E8B;&#x4EF6;&#x5982;&#x8282;&#x70B9;&#x66F4;&#x65B0;&#x53EF;&#x80FD;&#x4F1A;&#x89E6;&#x53D1;&#x91CD;&#x65B0;&#x8C03;&#x5EA6;;</p>
<p><code>Wait</code>&#xFF1A;&#x4EC5;&#x548C;<code>Permit</code>&#x63D2;&#x4EF6;&#x6709;&#x5173;&#xFF0C;&#x8981;&#x6C42;Pod&#x8FDB;&#x5165;&#x7B49;&#x5F85;&#x72B6;&#x6001;;</p>
<p><code>Skip</code>&#xFF1A;&#x8DF3;&#x8FC7;&#x5F53;&#x524D;&#x63D2;&#x4EF6;&#x68C0;&#x67E5;;</p>
<p><code>Pending</code>&#x662F;&#x5916;&#x90E8;&#x4F9D;&#x8D56;&#x6761;&#x4EF6;&#x4E0D;&#x6EE1;&#x8DB3;&#x5BFC;&#x81F4;&#x7684;&#x7B49;&#x5F85;&#xFF0C;&#x5982;&#x5B58;&#x50A8;&#x5377;&#x672A;&#x51C6;&#x5907;&#x597D;&#x6216;&#x6709;&#x4F9D;&#x8D56;Pod&#x7684;&#x5904;&#x7406;&#x9879;&#x672A;&#x5B8C;&#x6210;;</p>
<h4 id="&#x6838;&#x5FC3;&#x51FD;&#x6570;findnodesthatfitpod"><a name="&#x6838;&#x5FC3;&#x51FD;&#x6570;findnodesthatfitpod" class="plugin-anchor" href="#&#x6838;&#x5FC3;&#x51FD;&#x6570;findnodesthatfitpod"><i class="fa fa-link" aria-hidden="true"></i></a>&#x6838;&#x5FC3;&#x51FD;&#x6570;findNodesThatFitPod</h4>
<pre class="language-"><code class="lang-Go">func (sched *Scheduler) findNodesThatFitPod(ctx context.Context, fwk framework.Framework, state *framework.CycleState, pod *v1.Pod) ([]*framework.NodeInfo, framework.Diagnosis, error) {
    logger := klog.FromContext(ctx)
    // &#x521D;&#x59CB;&#x5316;&#x8282;&#x70B9;&#x7EA7;&#x7684;&#x8BCA;&#x65AD;&#x5B57;&#x5178;
    diagnosis := framework.Diagnosis{
        NodeToStatus: framework.NewDefaultNodeToStatus(),
    }
    // &#x83B7;&#x53D6;&#x5168;&#x91CF;&#x8282;&#x70B9;&#x5217;&#x8868;
    allNodes, err := sched.nodeInfoSnapshot.NodeInfos().List()
    if err != nil {
        return nil, diagnosis, err
    }
    // &#x8FD0;&#x884C;PreFilter&#x6269;&#x5C55;&#x70B9;&#x7684;&#x63D2;&#x4EF6;
    // &#x8FD4;&#x56DE;&#x503C;&#x4E3A; &#x8FC7;&#x6EE4;&#x540E;&#x7684;&#x8282;&#x70B9;(&#x5168;&#x91CF;&#x4E3A;nil)&#x3001;&#x63D2;&#x4EF6;&#x8FD0;&#x884C;&#x7ED3;&#x679C;(Success/Error/Unschedulable/UnschedulableAndUnresolvable/Wait/Skip/Pending)&#x3001;&#x5BFC;&#x81F4;&#x4E0D;&#x53EF;&#x8C03;&#x5EA6;&#x7684;&#x63D2;&#x4EF6;&#x96C6;&#x5408;
    preRes, s, unscheduledPlugins := fwk.RunPreFilterPlugins(ctx, state, pod)
    diagnosis.UnschedulablePlugins = unscheduledPlugins
    if !s.IsSuccess() {
        if !s.IsRejected() {
            // &#x5982;&#x679C;&#x662F;Error/Skip&#x76F4;&#x63A5;&#x8FD4;&#x56DE;
            return nil, diagnosis, s.AsError()
        }
        // &#x66F4;&#x65B0;&#x8282;&#x70B9;&#x4E0D;&#x53EF;&#x7528;&#x539F;&#x56E0;Unschedulable/UnschedulableAndUnresolvable &#x62A2;&#x5360;&#x76F8;&#x5173;
        diagnosis.NodeToStatus.SetAbsentNodesStatus(s)

        // &#x8FD4;&#x56DE;&#x5931;&#x8D25; &#x7EC4;&#x88C5;&#x9519;&#x8BEF;&#x4FE1;&#x606F;
        msg := s.Message()
        diagnosis.PreFilterMsg = msg
        logger.V(5).Info(&quot;Status after running PreFilter plugins for pod&quot;, &quot;pod&quot;, klog.KObj(pod), &quot;status&quot;, msg)
        diagnosis.AddPluginStatus(s)
        return nil, diagnosis, nil
    }

    // &#x903B;&#x8F91;1 &#x5982;&#x679C;&#x5B58;&#x5728;&#x88AB;&#x63D0;&#x540D;&#x8282;&#x70B9;&#x5B57;&#x6BB5; &#x5C1D;&#x8BD5;&#x5904;&#x7406;&#x88AB;&#x63D0;&#x540D;&#x8282;&#x70B9;
    if len(pod.Status.NominatedNodeName) &gt; 0 {
        // evaluateNominatedNode()&#x65B9;&#x6CD5;&#x5185;&#x90E8;&#x8C03;&#x7528;&#x4E86;findNodesThatPassFilters()&#x548C;findNodesThatPassExtenders()
        // &#x548C;&#x903B;&#x8F91;2&#x4E2D;&#x5B9E;&#x9645;&#x903B;&#x8F91;&#x4E00;&#x81F4;
        feasibleNodes, err := sched.evaluateNominatedNode(ctx, pod, fwk, state, diagnosis)
        if err != nil {
            logger.Error(err, &quot;Evaluation failed on nominated node&quot;, &quot;pod&quot;, klog.KObj(pod), &quot;node&quot;, pod.Status.NominatedNodeName)
        }
        // &#x6709;&#x88AB;&#x63D0;&#x540D;&#x8282;&#x70B9;&#x5207;&#x901A;&#x8FC7;&#x63D2;&#x4EF6;&#x7684;&#x60C5;&#x51B5;&#x8FD4;&#x56DE;&#x6210;&#x529F;&#x7ED3;&#x679C;
        if len(feasibleNodes) != 0 {
            return feasibleNodes, diagnosis, nil
        }
    }

    // &#x903B;&#x8F91;2 Pod&#x4FE1;&#x606F;&#x4E0D;&#x5B58;&#x5728;&#x88AB;&#x63D0;&#x540D;&#x8282;&#x70B9;&#x5B57;&#x6BB5; &#x6B63;&#x5E38;&#x5904;&#x7406;
    nodes := allNodes
    if !preRes.AllNodes() {
        nodes = make([]*framework.NodeInfo, 0, len(preRes.NodeNames))
        for nodeName := range preRes.NodeNames {
            if nodeInfo, err := sched.nodeInfoSnapshot.Get(nodeName); err == nil {
                nodes = append(nodes, nodeInfo)
            }
        }
        diagnosis.NodeToStatus.SetAbsentNodesStatus(framework.NewStatus(framework.UnschedulableAndUnresolvable, fmt.Sprintf(&quot;node(s) didn&apos;t satisfy plugin(s) %v&quot;, sets.List(unscheduledPlugins))))
    }
    // &#x8FD0;&#x884C;Filter&#x6269;&#x5C55;&#x70B9;&#x7684;&#x63D2;&#x4EF6;
    feasibleNodes, err := sched.findNodesThatPassFilters(ctx, fwk, state, pod, &amp;diagnosis, nodes)
    processedNodes := len(feasibleNodes) + diagnosis.NodeToStatus.Len()
    sched.nextStartNodeIndex = (sched.nextStartNodeIndex + processedNodes) % len(allNodes)
    if err != nil {
        return nil, diagnosis, err
    }

    feasibleNodesAfterExtender, err := findNodesThatPassExtenders(ctx, sched.Extenders, pod, feasibleNodes, diagnosis.NodeToStatus)
    if err != nil {
        return nil, diagnosis, err
    }
    if len(feasibleNodesAfterExtender) != len(feasibleNodes) {
        if diagnosis.UnschedulablePlugins == nil {
            diagnosis.UnschedulablePlugins = sets.New[string]()
        }
        diagnosis.UnschedulablePlugins.Insert(framework.ExtenderName)
    }

    return feasibleNodesAfterExtender, diagnosis, nil
}
</code></pre>
<h4 id="prefilter&#x6269;&#x5C55;&#x70B9;"><a name="prefilter&#x6269;&#x5C55;&#x70B9;" class="plugin-anchor" href="#prefilter&#x6269;&#x5C55;&#x70B9;"><i class="fa fa-link" aria-hidden="true"></i></a>PreFilter&#x6269;&#x5C55;&#x70B9;</h4>
<p><code>PreFilter</code>&#x7684;&#x4F5C;&#x7528;&#x4E3B;&#x8981;&#x662F;&#x7F29;&#x5C0F;&#x96C6;&#x7FA4;&#x8303;&#x56F4;&#xFF0C;&#x53EF;&#x80FD;&#x4F1A;&#x6536;&#x96C6;&#x96C6;&#x7FA4;/&#x8282;&#x70B9;&#x4FE1;&#x606F;&#xFF0C;&#x4E00;&#x822C;&#x4F1A;&#x901A;&#x8FC7;<code>cycleState.Write()</code>&#x65B9;&#x6CD5;&#xFF0C;&#x4EE5;<code>&#x6269;&#x5C55;&#x70B9;+&#x63D2;&#x4EF6;&#x540D;</code>&#x4E3A;key&#x5199;&#x5165;<code>CycleState</code>&#x5BF9;&#x8C61;&#x4E2D;&#x3002;</p>
<pre class="language-"><code class="lang-Go">func (f *frameworkImpl) RunPreFilterPlugins(ctx context.Context, state *framework.CycleState, pod *v1.Pod) (_ *framework.PreFilterResult, status *framework.Status, _ sets.Set[string]) {
    // &#x5F00;&#x59CB;&#x65F6;&#x95F4;&#x6233;
    startTime := time.Now()
    // &#x5DF2;&#x7ECF;&#x5728;PreFilter&#x6269;&#x5C55;&#x70B9;&#x5904;&#x7406;&#x8FC7;&#x7684;&#x63D2;&#x4EF6;&#x8DF3;&#x8FC7;Filter&#x6269;&#x5C55;&#x70B9;&#x7684;&#x5904;&#x7406;
    skipPlugins := sets.New[string]()
    defer func() {
        state.SkipFilterPlugins = skipPlugins
        metrics.FrameworkExtensionPointDuration.WithLabelValues(metrics.PreFilter, status.Code().String(), f.profileName).Observe(metrics.SinceInSeconds(startTime))
    }()
    // &#x521D;&#x59CB;&#x5316;&#x53D8;&#x91CF;
    var result *framework.PreFilterResult
    pluginsWithNodes := sets.New[string]()
    logger := klog.FromContext(ctx)
    verboseLogs := logger.V(4).Enabled()
    if verboseLogs {
        logger = klog.LoggerWithName(logger, &quot;PreFilter&quot;)
    }
    var returnStatus *framework.Status
    // &#x904D;&#x5386;&#x5F53;&#x524D;&#x6269;&#x5C55;&#x70B9;&#x7684;&#x63D2;&#x4EF6;&#x5217;&#x8868;
    for _, pl := range f.preFilterPlugins {
        ctx := ctx
        if verboseLogs {
            logger := klog.LoggerWithName(logger, pl.Name())
            ctx = klog.NewContext(ctx, logger)
        }
        // &#x8FD0;&#x884C;&#x5355;&#x4E2A;&#x63D2;&#x4EF6; &#x8FD4;&#x56DE;&#x7ED3;&#x679C;&#x548C;&#x72B6;&#x6001;
        // PreFilter&#x4E00;&#x822C;&#x90FD;&#x662F;&#x51C6;&#x5907;&#x5DE5;&#x4F5C; &#x6240;&#x4EE5;&#x57FA;&#x672C;&#x4E0A;&#x8FD4;&#x56DE;&#x503C;PreFilterResult&#x90FD;&#x662F;nil
        r, s := f.runPreFilterPlugin(ctx, pl, state, pod)
        if s.IsSkip() {
            skipPlugins.Insert(pl.Name())
            continue
        }
        // status&#x4E0D;&#x662F;Success&#x65F6; &#x8FD4;&#x56DE;&#x6216;&#x8BB0;&#x5F55;&#x72B6;&#x6001;
        if !s.IsSuccess() {
            s.SetPlugin(pl.Name())
            if s.Code() == framework.UnschedulableAndUnresolvable {
                // &#x9759;&#x6001;&#x6761;&#x4EF6;&#x4E0D;&#x4F1A;&#x88AB;&#x6EE1;&#x8DB3; UnschedulableAndUnresolvable&#x72B6;&#x6001;&#x76F4;&#x63A5;&#x9000;&#x51FA;
                return nil, s, nil
            }
            if s.Code() == framework.Unschedulable {
                // &#x52A8;&#x6001;&#x6761;&#x4EF6;&#x53EF;&#x80FD;&#x540E;&#x9762;&#x4F1A;&#x88AB;&#x6EE1;&#x8DB3; Unschedulable&#x72B6;&#x6001;&#x53EF;&#x80FD;&#x89E6;&#x53D1;&#x62A2;&#x5360;&#x6D41;&#x7A0B;
                returnStatus = s
                continue
            }
            return nil, framework.AsStatus(fmt.Errorf(&quot;running PreFilter plugin %q: %w&quot;, pl.Name(), s.AsError())).WithPlugin(pl.Name()), nil
        }
        // &#x53EA;&#x6709;&#x5728;PreFilter&#x9636;&#x6BB5;&#x7F29;&#x5C0F;&#x4E86;&#x8282;&#x70B9;&#x8303;&#x56F4; &#x5373;&#x8FD4;&#x56DE;&#x4E0D;&#x662F;&#x5168;&#x91CF;&#x7684;&#x8282;&#x70B9;&#x96C6;&#x5408;&#x65F6;
        if !r.AllNodes() {
            // &#x8BB0;&#x5F55;&#x4F7F;&#x8282;&#x70B9;&#x8303;&#x56F4;&#x7F29;&#x5C0F;&#x7684;&#x63D2;&#x4EF6;
            pluginsWithNodes.Insert(pl.Name())
        }
        // &#x5408;&#x5E76;PreFilter&#x7ED3;&#x679C;
        result = result.Merge(r)
        // &#x53D6;&#x4EA4;&#x96C6;&#x540E;&#x8282;&#x70B9;&#x96C6;&#x5408;&#x4E3A;&#x7A7A; &#x4E5F;&#x5C31;&#x662F;PreFilter&#x9636;&#x6BB5;&#x7B5B;&#x6389;&#x4E86;&#x6240;&#x6709;&#x7684;&#x8282;&#x70B9;
        if !result.AllNodes() &amp;&amp; len(result.NodeNames) == 0 {
            msg := fmt.Sprintf(&quot;node(s) didn&apos;t satisfy plugin(s) %v simultaneously&quot;, sets.List(pluginsWithNodes))
            if len(pluginsWithNodes) == 1 {
                msg = fmt.Sprintf(&quot;node(s) didn&apos;t satisfy plugin %v&quot;, sets.List(pluginsWithNodes)[0])
            }
            return result, framework.NewStatus(framework.UnschedulableAndUnresolvable, msg), pluginsWithNodes
        }
    }
    return result, returnStatus, pluginsWithNodes
}
</code></pre>
<p>&#x4E00;&#x4E2A;&#x63D2;&#x4EF6;&#x53EF;&#x4EE5;&#x5B9E;&#x73B0;&#x591A;&#x4E2A;&#x6269;&#x5C55;&#x70B9;&#x7684;&#x63A5;&#x53E3;&#xFF0C;&#x5982;<code>Fit</code>&#x63D2;&#x4EF6;&#x5C31;&#x540C;&#x65F6;&#x5B9E;&#x73B0;&#x4E86;<code>PreFilter</code>&#x3001;<code>Filter</code>&#x548C;<code>Score</code>&#x3002;</p>
<h4 id="filter&#x6269;&#x5C55;&#x70B9;"><a name="filter&#x6269;&#x5C55;&#x70B9;" class="plugin-anchor" href="#filter&#x6269;&#x5C55;&#x70B9;"><i class="fa fa-link" aria-hidden="true"></i></a>Filter&#x6269;&#x5C55;&#x70B9;</h4>
<p>&#x4EE5;&#x6709;&#x88AB;&#x63D0;&#x540D;&#x8282;&#x70B9;&#x7684;&#x5904;&#x7406;&#x6D41;&#x7A0B;&#x4E3A;&#x4F8B;&#xFF0C;&#x4E0E;&#x6807;&#x51C6;&#x6D41;&#x7A0B;&#x76F8;&#x540C;&#xFF0C;<code>Filter</code>&#x9636;&#x6BB5;&#x7684;&#x4E24;&#x4E2A;&#x91CD;&#x8981;&#x65B9;&#x6CD5;&#x4E3A;<code>findNodesThatPassFilters()</code>&#x548C;<code>findNodesThatPassExtenders</code>&#x3002;</p>
<pre class="language-"><code class="lang-Go">func (sched *Scheduler) evaluateNominatedNode(ctx context.Context, pod *v1.Pod, fwk framework.Framework, state *framework.CycleState, diagnosis framework.Diagnosis) ([]*framework.NodeInfo, error) {
    // &#x83B7;&#x53D6;&#x88AB;&#x63D0;&#x540D;Node&#x7684;&#x4FE1;&#x606F;
    nnn := pod.Status.NominatedNodeName
    nodeInfo, err := sched.nodeInfoSnapshot.Get(nnn)
    if err != nil {
        return nil, err
    }
    // &#x51C6;&#x5907;&#x8282;&#x70B9;&#x5217;&#x8868;
    node := []*framework.NodeInfo{nodeInfo}
    // &#x9636;&#x6BB5;1 &#x8FD0;&#x884C;Filter&#x63D2;&#x4EF6;&#x8FD4;&#x56DE;
    feasibleNodes, err := sched.findNodesThatPassFilters(ctx, fwk, state, pod, &amp;diagnosis, node)
    if err != nil {
        return nil, err
    }
    // &#x9636;&#x6BB5;2 &#x4ECD;&#x5C5E;&#x4E8E;Filter&#x6269;&#x5C55;&#x70B9; &#x8FD0;&#x884C;&#x81EA;&#x5B9A;&#x4E49;&#x6269;&#x5C55;&#x8FC7;&#x6EE4;&#x63D2;&#x4EF6;
    feasibleNodes, err = findNodesThatPassExtenders(ctx, sched.Extenders, pod, feasibleNodes, diagnosis.NodeToStatus)
    if err != nil {
        return nil, err
    }
    // &#x8FD4;&#x56DE;feasibleNodes&#x5217;&#x8868;
    return feasibleNodes, nil
}
</code></pre>
<p><code>findNodesThatPassFilters()</code>&#x65B9;&#x6CD5;&#x8FC7;&#x6EE4;&#x51FA;&#x4E86;&#x901A;&#x8FC7;<code>Filter</code>&#x63D2;&#x4EF6;&#x7684;&#x8282;&#x70B9;&#x5217;&#x8868;&#x3002;</p>
<pre class="language-"><code class="lang-Go">func (sched *Scheduler) findNodesThatPassFilters(
    ctx context.Context,
    fwk framework.Framework,
    state *framework.CycleState,
    pod *v1.Pod,
    diagnosis *framework.Diagnosis,
    nodes []*framework.NodeInfo) ([]*framework.NodeInfo, error) {
    numAllNodes := len(nodes)
    // &#x63D0;&#x524D;&#x786E;&#x5B9A;&#x8981;&#x521D;&#x6B65;&#x8FC7;&#x6EE4;&#x51FA;&#x7684;&#x8282;&#x70B9;&#x6570;&#x91CF;
    numNodesToFind := sched.numFeasibleNodesToFind(fwk.PercentageOfNodesToScore(), int32(numAllNodes))
    // &#x5982;&#x679C;&#x8C03;&#x5EA6;&#x5468;&#x671F;&#x6CA1;&#x6709;&#x5176;&#x4ED6;&#x6269;&#x5C55;&#x70B9; &#x90A3;&#x8282;&#x70B9;&#x6570;&#x91CF;&#x5FC5;&#x987B;&#x662F;1
    if !sched.hasExtenderFilters() &amp;&amp; !sched.hasScoring(fwk) {
        numNodesToFind = 1
    }

    // &#x521D;&#x59CB;&#x5316;&#x53D8;&#x91CF;
    feasibleNodes := make([]*framework.NodeInfo, numNodesToFind)
    // &#x5982;&#x679C;Filter&#x6269;&#x5C55;&#x70B9;&#x6CA1;&#x6709;&#x63D2;&#x4EF6; &#x907F;&#x514D;&#x5934;&#x90E8;&#x8282;&#x70B9;&#x6210;&#x4E3A;&#x70ED;&#x70B9; &#x4ECE;&#x7D22;&#x5F15;&#x70B9;&#x62FF;&#x591F;&#x6570;&#x91CF;&#x7684;Node&#x5C31;&#x8FD4;&#x56DE;
    if !fwk.HasFilterPlugins() {
        for i := range feasibleNodes {
            feasibleNodes[i] = nodes[(sched.nextStartNodeIndex+i)%numAllNodes]
        }
        return feasibleNodes, nil
    }
    // &#x6709;Filter&#x63D2;&#x4EF6;&#x7684;&#x6807;&#x51C6;&#x6D41;&#x7A0B;
    errCh := parallelize.NewErrorChannel()
    var feasibleNodesLen int32
    ctx, cancel := context.WithCancel(ctx)
    defer cancel()

    type nodeStatus struct {
        node   string
        status *framework.Status
    }
    result := make([]*nodeStatus, numAllNodes)
    // &#x5B9A;&#x4E49;checkNode&#x51FD;&#x6570; &#x5373;&#x6BCF;&#x4E2A;&#x8282;&#x70B9;&#x7684;Filter&#x903B;&#x8F91;
    checkNode := func(i int) {
        nodeInfo := nodes[(sched.nextStartNodeIndex+i)%numAllNodes]
        // &#x8FD0;&#x884C;Filter&#x63D2;&#x4EF6;
        status := fwk.RunFilterPluginsWithNominatedPods(ctx, state, pod, nodeInfo)
        if status.Code() == framework.Error {
            errCh.SendErrorWithCancel(status.AsError(), cancel)
            return
        }
        if status.IsSuccess() {
           // &#x8BA1;&#x6570;&#x5148;&#x52A0;&#x4E00;&#x518D;&#x5224;&#x65AD;
            length := atomic.AddInt32(&amp;feasibleNodesLen, 1)
            if length &gt; numNodesToFind {
                // &#x5982;&#x679C;&#x5DF2;&#x7ECF;&#x8D85;&#x8FC7;&#x76EE;&#x6807;&#x503C; &#x505C;&#x6B62;&#x6240;&#x6709;&#x5269;&#x4F59;&#x8282;&#x70B9;&#x7684;&#x68C0;&#x67E5;&#x5E76;&#x4F1A;&#x9000;&#x8BA1;&#x6570;
                cancel()
                atomic.AddInt32(&amp;feasibleNodesLen, -1)
            } else {
                // &#x5728;&#x8303;&#x56F4;&#x5185;&#x5C31;&#x6B63;&#x5E38;&#x6DFB;&#x52A0;&#x8282;&#x70B9;
                feasibleNodes[length-1] = nodeInfo
            }
        } else {
            // &#x63D2;&#x4EF6;&#x6267;&#x884C;&#x5931;&#x8D25;&#x8BB0;&#x5F55;&#x9519;&#x8BEF;&#x4FE1;&#x606F;
            result[i] = &amp;nodeStatus{node: nodeInfo.Node().Name, status: status}
        }
    }

    // &#x8BB0;&#x5F55;&#x5F00;&#x59CB;&#x65F6;&#x95F4;
    beginCheckNode := time.Now()
    statusCode := framework.Success
    defer func() {
        metrics.FrameworkExtensionPointDuration.WithLabelValues(metrics.Filter, statusCode.String(), fwk.ProfileName()).Observe(metrics.SinceInSeconds(beginCheckNode))
    }()

    // &#x4F7F;&#x7528;&#x5E76;&#x884C;&#x5668;&#x68C0;&#x67E5;&#x8282;&#x70B9;
    fwk.Parallelizer().Until(ctx, numAllNodes, checkNode, metrics.Filter)
    // &#x907F;&#x514D;&#x5E76;&#x53D1;&#x6761;&#x4EF6;&#x4E0B;&#x7684;&#x8D85;&#x989D;&#x8BA1;&#x6570;&#x95EE;&#x9898;
    feasibleNodes = feasibleNodes[:feasibleNodesLen]
    // &#x805A;&#x5408;&#x8282;&#x70B9;&#x7ED3;&#x679C;&#x5230;diagnosis&#x5BF9;&#x8C61;
    for _, item := range result {
        if item == nil {
            continue
        }
        diagnosis.NodeToStatus.Set(item.node, item.status)
        diagnosis.AddPluginStatus(item.status)
    }
    // &#x5982;&#x8FC7;errCh&#x6536;&#x5230;&#x9519;&#x8BEF;&#x8FD4;&#x56DE;&#x7B5B;&#x9009;&#x7ED3;&#x679C;&#x548C;&#x9519;&#x8BEF;
    if err := errCh.ReceiveError(); err != nil {
        statusCode = framework.Error
        return feasibleNodes, err
    }
    return feasibleNodes, nil
}
</code></pre>
<h5 id="&#x8282;&#x70B9;&#x5217;&#x8868;&#x957F;&#x5EA6;&#x786E;&#x5B9A;&#x89C4;&#x5219;"><a name="&#x8282;&#x70B9;&#x5217;&#x8868;&#x957F;&#x5EA6;&#x786E;&#x5B9A;&#x89C4;&#x5219;" class="plugin-anchor" href="#&#x8282;&#x70B9;&#x5217;&#x8868;&#x957F;&#x5EA6;&#x786E;&#x5B9A;&#x89C4;&#x5219;"><i class="fa fa-link" aria-hidden="true"></i></a>&#x8282;&#x70B9;&#x5217;&#x8868;&#x957F;&#x5EA6;&#x786E;&#x5B9A;&#x89C4;&#x5219;</h5>
<p>&#x4E3A;&#x4E86;&#x5E73;&#x8861;&#x8C03;&#x5EA6;&#x7684;&#x6548;&#x7387;&#xFF0C;&#x4E0D;&#x4F1A;&#x628A;&#x6240;&#x6709;&#x7B26;&#x5408;&#x6761;&#x4EF6;&#x7684;&#x8282;&#x70B9;&#x90FD;&#x5217;&#x51FA;&#x5E76;&#x6253;&#x5206;&#xFF0C;&#x6240;&#x4EE5;<code>feasiblenodes</code>&#x5207;&#x7247;&#x4F1A;&#x6709;&#x4E00;&#x4E2A;&#x9884;&#x4F30;&#x957F;&#x5EA6;&#xFF0C;&#x6700;&#x5C0F;&#x957F;&#x5EA6;&#x662F;100&#x3002;<code>numFeasibleNodesToFind()</code>&#x62BD;&#x6837;&#x65B9;&#x6CD5;&#x63A5;&#x6536;&#x4E24;&#x4E2A;&#x53C2;&#x6570;&#xFF0C;&#x5206;&#x522B;&#x662F;&#x6253;&#x5206;&#x62BD;&#x6837;&#x767E;&#x5206;&#x6BD4;&#x548C;&#x96C6;&#x7FA4;&#x8282;&#x70B9;&#x603B;&#x6570;&#x3002;</p>
<pre class="language-"><code class="lang-Go">func (sched *Scheduler) numFeasibleNodesToFind(percentageOfNodesToScore *int32, numAllNodes int32) (numNodes int32) {
    // &#x8282;&#x70B9;&#x603B;&#x6570;&lt;100 &#x76F4;&#x63A5;&#x8FD4;&#x56DE;&#x8282;&#x70B9;&#x603B;&#x6570;
    if numAllNodes &lt; minFeasibleNodesToFind {
        return numAllNodes
    }

    // &#x6253;&#x5206;&#x62BD;&#x6837;&#x767E;&#x5206;&#x6BD4;&#x8BBE;&#x7F6E;
    var percentage int32
    if percentageOfNodesToScore != nil {
        percentage = *percentageOfNodesToScore
    } else {
        // DefaultPercentageOfNodesToScore=0&#x8868;&#x793A;&#x52A8;&#x6001;&#x9002;&#x5E94; &#x5728;&#x6B64;&#x5904;&#x91CD;&#x65B0;&#x8BBE;&#x7F6E;&#x503C;
        percentage = sched.percentageOfNodesToScore
    }
    // &#x52A8;&#x6001;&#x9002;&#x5E94;
    if percentage == 0 {
        // &#x62BD;&#x6837;&#x767E;&#x5206;&#x6BD4;&#x4E5F;&#x5C31;&#x662F; 50-(num/125) &#x6700;&#x4F4E;&#x767E;&#x5206;&#x6BD4;&#x662F;5
        percentage = int32(50) - numAllNodes/125
        if percentage &lt; minFeasibleNodesPercentageToFind {
            percentage = minFeasibleNodesPercentageToFind
        }
    }
    // &#x8BA1;&#x7B97;&#x6570;&#x91CF; &#x603B;&#x91CF;*&#x767E;&#x5206;&#x6BD4; &#x4E0D;&#x5C0F;&#x4E8E;&#x662F;100
    numNodes = numAllNodes * percentage / 100
    if numNodes &lt; minFeasibleNodesToFind {
        return minFeasibleNodesToFind
    }

    return numNodes
}
</code></pre>
<h5 id="&#x8FD0;&#x884C;filter&#x63D2;&#x4EF6;"><a name="&#x8FD0;&#x884C;filter&#x63D2;&#x4EF6;" class="plugin-anchor" href="#&#x8FD0;&#x884C;filter&#x63D2;&#x4EF6;"><i class="fa fa-link" aria-hidden="true"></i></a>&#x8FD0;&#x884C;Filter&#x63D2;&#x4EF6;</h5>
<p><code>RunFilterPluginsWithNominatedPods()</code>&#x662F;&#x771F;&#x6B63;&#x8FD0;&#x884C;&#x63D2;&#x4EF6;<code>RunFilterPlugins()</code>&#x524D;&#x7684;&#x91CD;&#x8981;&#x65B9;&#x6CD5;&#xFF0C;&#x4E5F;&#x662F;Filter&#x63D2;&#x4EF6;&#x7684;&#x4E0A;&#x5C42;&#x5165;&#x53E3;&#x51FD;&#x6570;&#x3002;&#x5728;&#x4E4B;&#x524D;&#x5148;&#x8BF4;&#x660E;&#x4E00;&#x4E2A;&#x5173;&#x952E;&#x7684;&#x70B9;&#xFF0C;<code>NominatedPod</code>&#x662F;&#x5728;&#x62A2;&#x5360;&#x8BA1;&#x7B97;&#x540E;&#x4EA7;&#x751F;&#x7684;&#xFF0C;&#x4F1A;&#x5728;&#x540E;&#x7EED;&#x8C03;&#x5EA6;&#x5FAA;&#x73AF;&#x4E2D;&#x5C1D;&#x8BD5;&#x8C03;&#x5EA6;&#x3002;</p>
<p>&#x6B64;&#x5904;&#x7684;&#x5DE7;&#x5999;&#x8BBE;&#x8BA1;&#x5145;&#x5206;&#x8868;&#x73B0;&#x4E86;&#x8C03;&#x5EA6;&#x5668;&#x7684;<strong>&#x4FDD;&#x5B88;&#x51B3;&#x7B56;</strong>&#xFF0C;&#x4E24;&#x6B21;&#x63D2;&#x4EF6;&#x6267;&#x884C;&#x5FC5;&#x987B;&#x5168;&#x90E8;&#x901A;&#x8FC7;&#x624D;&#x7B97;&#x505A;&#x8282;&#x70B9;&#x53EF;&#x7528;&#xFF1A;&#x7B2C;&#x4E00;&#x6B21;&#x5FAA;&#x73AF;&#x5148;&#x8BBE;&#x7F6E;&#x6A21;&#x62DF;&#x6DFB;&#x52A0;&#x63D0;&#x540D;Pod&#x6807;&#x8BC6;&#x4F4D;<code>podsAdded</code>&#xFF0C;&#x7136;&#x540E;&#x8C03;&#x7528;<code>RunFilterPlugins()</code>&#x6267;&#x884C;<code>Filter</code>&#x63D2;&#x4EF6;&#xFF0C;&#x7B2C;&#x4E8C;&#x6B21;&#x65F6;&#x5224;&#x65AD;&#x6807;&#x8BC6;&#x4F4D;&#x548C;&#x4E0A;&#x4E00;&#x6B21;&#x7ED3;&#x679C;&#xFF0C;&#x5982;&#x679C;&#x6CA1;&#x6709;&#x63D0;&#x540D;Pod&#x53EF;&#x6A21;&#x62DF;&#x6216;&#x6A21;&#x62DF;&#x540E;&#x8282;&#x70B9;&#x4E0D;&#x53EF;&#x7528;&#xFF0C;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;&#x4E0D;&#x7528;&#x518D;&#x6267;&#x884C;&#x7B2C;&#x4E8C;&#x6B21;&#x3002;&#x5982;&#x679C;&#x8003;&#x8651;&#x4E86;&#x63D0;&#x540D;Pod&#x4E14;&#x7B2C;&#x4E00;&#x6B21;&#x7ED3;&#x679C;&#x4E3A;&#x6210;&#x529F;&#xFF0C;&#x90A3;&#x4E48;&#x8FD8;&#x9700;&#x8981;&#x6267;&#x884C;&#x7B2C;&#x4E8C;&#x6B21;&#xFF0C;&#x4FDD;&#x8BC1;&#x5982;Pod&#x95F4;&#x4EB2;&#x548C;&#x6027;&#x7B49;&#x6761;&#x4EF6;&#x5728;&#x6CA1;&#x6709;&#x63D0;&#x540D;Pod&#x5728;&#x8282;&#x70B9;&#x4E0A;&#x8FD0;&#x884C;&#x65F6;&#x4ECD;&#x7136;&#x80FD;&#x591F;&#x6EE1;&#x8DB3;&#x3002;&#x5982;&#x679C;&#x7B2C;&#x4E8C;&#x6B21;&#x8BC4;&#x4F30;&#x5931;&#x8D25;&#xFF0C;&#x90A3;&#x4E48;&#x4F1A;&#x8986;&#x76D6;&#x7B2C;&#x4E00;&#x6B21;&#x7684;&#x8BC4;&#x4F30;&#x7ED3;&#x679C;&#xFF0C;&#x8BA4;&#x4E3A;&#x5F53;&#x524D;&#x8282;&#x70B9;&#x4E0D;&#x53EF;&#x7528;&#x3002;</p>
<pre class="language-"><code class="lang-Go">func (f *frameworkImpl) RunFilterPluginsWithNominatedPods(ctx context.Context, state *framework.CycleState, pod *v1.Pod, info *framework.NodeInfo) *framework.Status {
    var status *framework.Status

    podsAdded := false
    logger := klog.FromContext(ctx)
    logger = klog.LoggerWithName(logger, &quot;FilterWithNominatedPods&quot;)
    ctx = klog.NewContext(ctx, logger)
    // &#x4E24;&#x6B21;&#x5FAA;&#x73AF;
    for i := 0; i &lt; 2; i++ {
        stateToUse := state
        nodeInfoToUse := info
        // &#x7B2C;&#x4E00;&#x8F6E;&#x5FAA;&#x73AF;&#x5047;&#x8BBE;&#x5E26;&#x4E0A;NominatedPod&#x4E00;&#x8D77;&#x8BC4;&#x4F30;
        if i == 0 {
            var err error
            podsAdded, stateToUse, nodeInfoToUse, err = addNominatedPods(ctx, f, pod, state, info)
            if err != nil {
                return framework.AsStatus(err)
            }
        } else if !podsAdded || !status.IsSuccess() {
            // i==1&#x65F6;&#x624D;&#x5224;&#x65AD;
            break
        }

        status = f.RunFilterPlugins(ctx, stateToUse, pod, nodeInfoToUse)
        if !status.IsSuccess() &amp;&amp; !status.IsRejected() {
        // &#x4E24;&#x6B21;&#x5FAA;&#x73AF;&#x4E2D;&#x53EA;&#x8981;&#x6709;&#x4E00;&#x6B21;&#x7ED3;&#x679C;&#x662F;&#x5931;&#x8D25; &#x5C31;&#x8BA4;&#x4E3A;&#x662F;&#x5931;&#x8D25;&#x7684;
            return status
        }
    }

    return status
}
</code></pre>
<p><code>addNominatedPods()</code>&#x51FD;&#x6570;&#x628A;&#x88AB;&#x63D0;&#x540D;&#x5230;&#x5F53;&#x524D;&#x8282;&#x70B9;&#x4E14;&#x4F18;&#x5148;&#x7EA7;&#x9AD8;&#x4E8E;&#x5F53;&#x524D;&#x5BF9;&#x8C61;&#x7684;Pod&#x4E34;&#x65F6;&#x6DFB;&#x52A0;&#x5230;&#x8282;&#x70B9;&#x4FE1;&#x606F;&#x4E2D;&#xFF0C;&#x4EE5;&#x6A21;&#x62DF;&#x6210;&#x529F;&#x62A2;&#x5360;&#x540E;&#x7684;&#x72B6;&#x6001;&#x3002;</p>
<pre class="language-"><code class="lang-Go">func addNominatedPods(ctx context.Context, fh framework.Handle, pod *v1.Pod, state *framework.CycleState, nodeInfo *framework.NodeInfo) (bool, *framework.CycleState, *framework.NodeInfo, error) {
    if fh == nil {
        return false, state, nodeInfo, nil
    }
    // &#x8981;&#x5728;&#x5F53;&#x524D;Node&#x4E0A;&#x62A2;&#x5360;&#x7684;Pod&#x5217;&#x8868;
    nominatedPodInfos := fh.NominatedPodsForNode(nodeInfo.Node().Name)
    if len(nominatedPodInfos) == 0 {
    // &#x5982;&#x679C;&#x6CA1;&#x6709;&#x5C31;&#x8DF3;&#x8FC7;&#x8FD9;&#x4E00;&#x6B65;
        return false, state, nodeInfo, nil
    }
    // &#x5982;&#x679C;&#x6709;NominatedPod &#x62F7;&#x8D1D;&#x4E00;&#x4EFD;&#x5FEB;&#x7167;&#x548C;&#x72B6;&#x6001;&#x4FE1;&#x606F;
    nodeInfoOut := nodeInfo.Snapshot()
    stateOut := state.Clone()
    podsAdded := false
    // &#x904D;&#x5386;NominatedPod&#x5217;&#x8868;
    for _, pi := range nominatedPodInfos {
        // &#x4F18;&#x5148;&#x7EA7;&#x6BD4;&#x5F53;&#x524D;Pod&#x9AD8;&#x624D;&#x4F1A;&#x88AB;&#x5C1D;&#x8BD5;&#x52A0;&#x5165;NodeInfo
        if corev1.PodPriority(pi.Pod) &gt;= corev1.PodPriority(pod) &amp;&amp; pi.Pod.UID != pod.UID {
            nodeInfoOut.AddPodInfo(pi)
            // &#x4E0D;&#x662F;&#x76F4;&#x63A5;&#x52A0;&#x5165;
            status := fh.RunPreFilterExtensionAddPod(ctx, stateOut, pod, pi, nodeInfoOut)
            if !status.IsSuccess() {
                // &#x4EFB;&#x610F;&#x63D0;&#x540D;Pod&#x8C03;&#x5EA6;&#x5931;&#x8D25; &#x8868;&#x793A;&#x8282;&#x70B9;&#x539F;&#x56E0;&#x62A2;&#x5360;&#x5931;&#x8D25; &#x4E00;&#x7968;&#x5426;&#x51B3;
                return false, state, nodeInfo, status.AsError()
            }
            // &#x6210;&#x529F;&#x6A21;&#x62DF;&#x540E;&#x4FEE;&#x6539;&#x6807;&#x8BC6;&#x4F4D;
            podsAdded = true
        }
    }
    return podsAdded, stateOut, nodeInfoOut, nil
}
</code></pre>
<p>&#x8FD0;&#x884C;<code>Filter</code>&#x63D2;&#x4EF6;&#x7684;&#x5B9E;&#x9645;&#x5165;&#x53E3;&#x5728;<code>RunFilterPlugins()</code>&#x65B9;&#x6CD5;&#x4E2D;&#xFF0C;&#x548C;<code>PreFilter</code>&#x7684;&#x8C03;&#x7528;&#x7C7B;&#x4F3C;&#xFF0C;&#x90FD;&#x662F;&#x5FAA;&#x73AF;&#x6267;&#x884C;&#x96C6;&#x5408;&#x4E2D;&#x7684;&#x63D2;&#x4EF6;&#x7136;&#x540E;&#x8FD4;&#x56DE;&#x72B6;&#x6001;&#xFF0C;&#x6CA1;&#x6709;&#x9700;&#x8981;&#x7279;&#x522B;&#x8BF4;&#x660E;&#x7684;&#x5730;&#x65B9;&#x3002;</p>
<pre class="language-"><code class="lang-Go">func (f *frameworkImpl) RunFilterPlugins(
    ctx context.Context,
    state *framework.CycleState,
    pod *v1.Pod,
    nodeInfo *framework.NodeInfo,
) *framework.Status {
    logger := klog.FromContext(ctx)
    verboseLogs := logger.V(4).Enabled()
    if verboseLogs {
        logger = klog.LoggerWithName(logger, &quot;Filter&quot;)
    }

    for _, pl := range f.filterPlugins {
        if state.SkipFilterPlugins.Has(pl.Name()) {
            continue
        }
        ctx := ctx
        if verboseLogs {
            logger := klog.LoggerWithName(logger, pl.Name())
            ctx = klog.NewContext(ctx, logger)
        }
        if status := f.runFilterPlugin(ctx, pl, state, pod, nodeInfo); !status.IsSuccess() {
            if !status.IsRejected() {
                status = framework.AsStatus(fmt.Errorf(&quot;running %q filter plugin: %w&quot;, pl.Name(), status.AsError()))
            }
            status.SetPlugin(pl.Name())
            return status
        }
    }

    return nil
}
</code></pre>
<p>&#x56DE;&#x5230;&#x4E4B;&#x524D;&#x7684;&#x6D41;&#x7A0B;&#x4E2D;&#xFF0C;&#x4E5F;&#x5C31;&#x662F;<code>evaluateNominatedNode()</code>&#x65B9;&#x6CD5;&#x4E2D;&#xFF0C;&#x8FD9;&#x91CC;&#x6D89;&#x53CA;&#x5230;&#x8C03;&#x5EA6;&#x6269;&#x5C55;&#x5668;<code>Scheduler Extenders</code>&#xFF0C;&#x5728;&#x6B64;&#x5904;&#x5148;&#x4E0D;&#x8BE6;&#x7EC6;&#x8BF4;&#x660E;</p>
<pre class="language-"><code class="lang-Go">func findNodesThatPassExtenders(ctx context.Context, extenders []framework.Extender, pod *v1.Pod, feasibleNodes []*framework.NodeInfo, statuses *framework.NodeToStatus) ([]*framework.NodeInfo, error) {
    logger := klog.FromContext(ctx)

    // &#x904D;&#x5386;&#x6240;&#x6709;&#x6269;&#x5C55;&#x5668;
    for _, extender := range extenders {
        if len(feasibleNodes) == 0 {
            break
        }
        if !extender.IsInterested(pod) {
            continue
        }

        // &#x8C03;&#x7528;&#x6269;&#x5C55;&#x5668;&#x7684;Filter&#x65B9;&#x6CD5;
        // &#x8FD4;&#x56DE;&#x53EF;&#x7528;Node&#x5217;&#x8868;&#x3001;&#x5931;&#x8D25;&#x53EF;&#x91CD;&#x8BD5;&#x8282;&#x70B9;&#x5217;&#x8868;&#x3001;&#x5931;&#x8D25;&#x4E0D;&#x53EF;&#x91CD;&#x8BD5;&#x8282;&#x70B9;&#x5217;&#x8868;
        feasibleList, failedMap, failedAndUnresolvableMap, err := extender.Filter(pod, feasibleNodes)
        if err != nil {
            if extender.IsIgnorable() {
                logger.Info(&quot;Skipping extender as it returned error and has ignorable flag set&quot;, &quot;extender&quot;, extender, &quot;err&quot;, err)
                continue
            }
            return nil, err
        }
        // &#x72B6;&#x6001;&#x5199;&#x5165;
        for failedNodeName, failedMsg := range failedAndUnresolvableMap {
            statuses.Set(failedNodeName, framework.NewStatus(framework.UnschedulableAndUnresolvable, failedMsg))
        }

        for failedNodeName, failedMsg := range failedMap {
            if _, found := failedAndUnresolvableMap[failedNodeName]; found {
                // &#x4E24;&#x79CD;&#x5931;&#x8D25;&#x90FD;&#x5B58;&#x5728;&#x65F6; &#x53EA;&#x8BB0;&#x5F55;UnschedulableAndUnresolvable&#x72B6;&#x6001;&#x5C31;&#x53EF;&#x4EE5;
                continue
            }
            statuses.Set(failedNodeName, framework.NewStatus(framework.Unschedulable, failedMsg))
        }
        // &#x66F4;&#x65B0;&#x6700;&#x7EC8;&#x8282;&#x70B9;&#x5217;&#x8868;
        feasibleNodes = feasibleList
    }
    return feasibleNodes, nil
}
</code></pre>
<p>&#x81F3;&#x6B64;<code>Predicates</code>&#x9636;&#x6BB5;&#x4EE5;&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;<code>feasibleNodes</code>&#x4E3A;&#x7ED3;&#x675F;&#xFF0C;&#x7B80;&#x5355;&#x6765;&#x770B;&#x4E00;&#x4E0B;Pod&#x4E2D;&#x6CA1;&#x6709;<code>NominatedNodeName</code>&#x7684;&#x6807;&#x51C6;&#x60C5;&#x51B5;&#xFF0C;&#x90E8;&#x5206;&#x4EE3;&#x7801;&#x5982;&#x4E0B;&#xFF0C;&#x5E76;&#x6CA1;&#x6709;&#x5B9E;&#x9645;&#x4E0A;&#x7684;&#x533A;&#x522B;&#xFF0C;&#x57FA;&#x672C;&#x76F8;&#x5F53;&#x4E8E;&#x662F;&#x672A;&#x88AB;&#x5C01;&#x88C5;&#x7684;<code>evaluateNominatedNode()</code></p>
<pre class="language-"><code class="lang-Go">    // &#x521D;&#x59CB;&#x5316;nodes&#x4E3A;&#x5168;&#x90E8;&#x8282;&#x70B9;
    nodes := allNodes
    // &#x5982;&#x679C;Prefilter&#x9636;&#x6BB5;&#x8FD4;&#x56DE;&#x7684;&#x4E0D;&#x662F;&#x5168;&#x90E8;&#x8282;&#x70B9;
    // &#x5C31;&#x91CD;&#x65B0;&#x8BBE;&#x7F6E;nodes&#x4E3A;preRes&#x4E2D;&#x7684;&#x8282;&#x70B9;
    if !preRes.AllNodes() {
        nodes = make([]*framework.NodeInfo, 0, len(preRes.NodeNames))
        for nodeName := range preRes.NodeNames {
            if nodeInfo, err := sched.nodeInfoSnapshot.Get(nodeName); err == nil {
                nodes = append(nodes, nodeInfo)
            }
        }
        // &#x8BB0;&#x5F55;&#x8BCA;&#x65AD;&#x4FE1;&#x606F;
        diagnosis.NodeToStatus.SetAbsentNodesStatus(framework.NewStatus(framework.UnschedulableAndUnresolvable, fmt.Sprintf(&quot;node(s) didn&apos;t satisfy plugin(s) %v&quot;, sets.List(unscheduledPlugins))))
    }
    // &#x540C;evaluateNominatedNode()&#x4E2D;&#x7684;&#x8C03;&#x7528;&#x6D41;&#x7A0B;
    feasibleNodes, err := sched.findNodesThatPassFilters(ctx, fwk, state, pod, &amp;diagnosis, nodes)
    // &#x5904;&#x7406;&#x8FC7;&#x7684;&#x8282;&#x70B9;&#x6570;&#x91CF;=&#x901A;&#x8FC7;&#x6570;&#x91CF;+&#x672A;&#x901A;&#x8FC7;&#x6570;&#x91CF;
    processedNodes := len(feasibleNodes) + diagnosis.NodeToStatus.Len()
    // &#x66F4;&#x65B0;&#x4E0B;&#x6B21;&#x9009;&#x8282;&#x70B9;&#x7684;&#x8D77;&#x59CB;&#x7D22;&#x5F15;
    sched.nextStartNodeIndex = (sched.nextStartNodeIndex + processedNodes) % len(allNodes)
    if err != nil {
        return nil, diagnosis, err
    }
    // &#x540C;evaluateNominatedNode()&#x4E2D;&#x7684;&#x8C03;&#x7528;&#x6D41;&#x7A0B;
    feasibleNodesAfterExtender, err := findNodesThatPassExtenders(ctx, sched.Extenders, pod, feasibleNodes, diagnosis.NodeToStatus)
    if err != nil {
        return nil, diagnosis, err
    }
    // &#x5982;&#x679C;&#x8FD0;&#x884C;&#x6269;&#x5C55;&#x8FC7;&#x6EE4;&#x5668;&#x7684;&#x8282;&#x70B9;&#x6570;&#x91CF;&#x548C;&#x4E4B;&#x524D;&#x4E0D;&#x4E00;&#x6837; &#x66F4;&#x65B0;&#x4E0D;&#x53EF;&#x8C03;&#x5EA6;&#x63D2;&#x4EF6;&#x96C6;&#x5408;
    if len(feasibleNodesAfterExtender) != len(feasibleNodes) {
        if diagnosis.UnschedulablePlugins == nil {
            diagnosis.UnschedulablePlugins = sets.New[string]()
        }
        diagnosis.UnschedulablePlugins.Insert(framework.ExtenderName)
    }

    return feasibleNodesAfterExtender, diagnosis, nil
</code></pre>
<footer class="page-footer"><span class="copyright">&#xA9; 2025 lts0609. All rights reserved. all right reserved&#xFF0C;powered by Gitbook</span><span class="footer-modification">&#x6700;&#x540E;&#x66F4;&#x65B0;&#x65F6;&#x95F4;&#xFF1A;
2025-07-16 14:59:34
</span></footer>
<script>console.log("plugin-popup....");document.onclick = function(e){ e.target.tagName === "IMG" && window.open(e.target.src,e.target.src)}</script><style>img{cursor:pointer}</style> <link rel="stylesheet" type="text/css" href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css"> <script>     window.klipse_settings = {         selector: ".language-klipse, .lang-eval-clojure",         selector_eval_js: ".lang-eval-js",         selector_eval_python_client: ".lang-eval-python",         selector_eval_php: ".lang-eval-php",         selector_eval_scheme: ".lang-eval-scheme",         selector_eval_ruby: ".lang-eval-ruby",         selector_reagent: ".lang-reagent",        selector_google_charts: ".lang-google-chart",        selector_es2017: ".lang-eval-es2017",        selector_jsx: ".lang-eval-jsx",        selector_transpile_jsx: ".lang-transpile-jsx",        selector_render_jsx: ".lang-render-jsx",        selector_react: ".lang-react",        selector_eval_markdown: ".lang-render-markdown",        selector_eval_lambdaway: ".lang-render-lambdaway",        selector_eval_cpp: ".lang-eval-cpp",        selector_eval_html: ".lang-render-html",        selector_sql: ".lang-eval-sql",        selector_brainfuck: "lang-eval-brainfuck",        selector_js: ".lang-transpile-cljs"    }; </script> <script src="https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js"></script>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="03-Framework框架和调度流程.html" class="navigation navigation-prev " aria-label="Previous page: Framework框架和调度流程">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="05-详解调度周期SchedulingCycle-下.html" class="navigation navigation-next " aria-label="Next page: 详解调度周期SchedulingCycle(下)">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"详解调度周期SchedulingCycle(上)","level":"1.2.4","depth":2,"next":{"title":"详解调度周期SchedulingCycle(下)","level":"1.2.5","depth":2,"path":"kube-scheduler/05-详解调度周期SchedulingCycle-下.md","ref":"kube-scheduler/05-详解调度周期SchedulingCycle-下.md","articles":[]},"previous":{"title":"Framework框架和调度流程","level":"1.2.3","depth":2,"path":"kube-scheduler/03-Framework框架和调度流程.md","ref":"kube-scheduler/03-Framework框架和调度流程.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-highlight","-lunr","-search","-sharing","-sharing-plus","pageview-count","page-toc-button","page-treeview","back-to-top-button","splitter","code","search-pro","popup","scroll-to-top","auto-scroll-table","anchors","klipse","prism","tbfed-pagefooter","livereload"],"styles":{"pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css","website":"styles/website.css"},"pluginsConfig":{"tbfed-pagefooter":{"copyright":"© 2025 lts0609. All rights reserved.","modify_label":"最后更新时间：","modify_format":"YYYY-MM-DD HH:mm:ss"},"page-treeview":{"collapsed":false,"copyright":"","minHeaderCount":"1","minHeaderDeep":"1","sidebarHeader":"目录","collapse":true},"prism":{"css":["prismjs/themes/prism-tomorrow.css"],"lang":{"go":"go","yaml":"yaml"}},"scroll-to-top":{},"livereload":{},"splitter":{},"search-pro":{"multilingual":false,"indexing":{"delay":500,"minLength":2}},"auto-scroll-table":{},"popup":{},"code":{"copyButtons":true},"fontsettings":{"theme":"white","family":"sans","size":2},"page-toc-button":{"maxDepth":3,"minDepth":1,"position":"left"},"back-to-top-button":{},"pageview-count":{},"klipse":{"myConfigKey":"it's the default value","languages":["go","yaml"]},"theme-default":{"styles":{"pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css","website":"styles/website.css"},"showLevel":false},"anchors":{}},"theme":"default","author":"lts0609","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"Kubernetes Learning","language":"zh-hans","gitbook":"*","description":"Kubernetes源码学习"},"file":{"path":"kube-scheduler/04-详解调度周期SchedulingCycle-上.md","mtime":"2025-07-16T06:59:34.691Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2025-07-16T08:21:27.573Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-pageview-count/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-page-toc-button/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-splitter/splitter.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-code/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search-pro/jquery.mark.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search-pro/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-scroll-to-top/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-auto-scroll-table/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

